// Procedural World Generator in Rust
// Author: Cooter McGrew

// This project generates a 2D procedural world using Perlin noise for terrain generation.
// We'll build it step by step with heavily commented code to help anyone (including myself) understand it.

use noise::{NoiseFn, Perlin}; // Importing Perlin noise generator from the `noise` crate.
use std::fs::File;          // For saving the generated world as an image.
use std::io::Write;         // For writing data to the file.

fn main() {
    // STEP 1: Set up the Perlin noise generator.
    let perlin = Perlin::new(); // Create a new Perlin noise instance.

    // Define the dimensions of the world.
    let width = 512;  // Width of the world in pixels.
    let height = 512; // Height of the world in pixels.

    // Define the scale of the noise. A larger scale means more stretched-out features.
    let scale = 0.1;

    // STEP 2: Create a 2D grid to store the world data.
    // We'll store the height values (elevation) generated by Perlin noise.
    let mut world: Vec<Vec<f32>> = vec![vec![0.0; width]; height];

    // Generate the terrain using Perlin noise.
    for y in 0..height {
        for x in 0..width {
            // Scale the x and y coordinates to fit the noise scale.
            let nx = x as f64 * scale;
            let ny = y as f64 * scale;

            // Generate the noise value for the current (x, y) position.
            // Perlin noise returns a value between -1.0 and 1.0.
            let noise_value = perlin.get([nx, ny]) as f32;

            // Map the noise value to a 0.0 to 1.0 range for easier processing.
            world[y][x] = (noise_value + 1.0) / 2.0;
        }
    }

    // STEP 3: Save the world as a grayscale image to visualize the terrain.
    save_world_as_image(&world, "world.png").expect("Failed to save world image");

    println!("World generation complete! Check the generated image: world.png");
}

// Function to save the world data as a grayscale image.
fn save_world_as_image(world: &Vec<Vec<f32>>, filename: &str) -> Result<(), std::io::Error> {
    // Create a new file to save the image.
    let mut file = File::create(filename)?;

    // Write the PPM image header.
    // PPM is a simple image format that we can use to save the data as an image.
    file.write_all(b"P3\n")?; // P3 means ASCII-based color data.
    file.write_all(format!("{} {}\n", world[0].len(), world.len()).as_bytes())?; // Image dimensions.
    file.write_all(b"255\n")?; // Maximum color value.

    // Write the pixel data.
    for row in world {
        for &value in row {
            let gray = (value * 255.0) as u8; // Map the value to a range of 0-255 for grayscale.
            file.write_all(format!("{} {} {}\n", gray, gray, gray).as_bytes())?; // Write RGB values.
        }
    }

    Ok(())
}

// Future Steps:
// - Add biomes based on elevation (e.g., water, grass, mountains).
// - Generate rivers or other features.
// - Use color instead of grayscale to make the world visually appealing.
// - Add support for larger worlds with chunk-based rendering.

// NOTE: Make sure to include the `noise` crate in your Cargo.toml dependencies:
// [dependencies]
// noise = "0.8"
